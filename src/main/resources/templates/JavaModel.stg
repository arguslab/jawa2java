group JavaModelGenerator;

delimiters "$", "$"

CompilationUnit(package, imports, classDecl) ::= <<
$package$

$imports ; separator="\n"$

$classDecl$
>>

Package(pkgName) ::= <<
package $pkgName$;
>>

Import(className) ::= <<
import $className$;
>>

ClassDecl(accessFlag, className, exts, impls, fields, methods) ::= <<
$accessFlag$ class $className$$if(exts)$ extends $exts$$endif$$if(impls)$ implements $impls ; separator=", "$$endif$ {
  $fields ; separator="\n"$
  $methods ; separator="\n"$
}
>>

FieldDecl(attrTyp, attrName, annotations, accessFlag) ::= <<
$if(accessFlag)$$accessFlag$ $endif$$attrTyp$ $attrName$;
>>

MethodDecl(accessFlag, retTyp, methodName, params, localVars, body, catchClauses) ::= <<
$accessFlag$ $retTyp$ $methodName$($params ; separator=", "$) {
  $localVars ; separator="\n"$

  $body$
}
>>

Param(paramTyp, paramName) ::= <<
$paramTyp$ $paramName$
>>

Body(statements) ::= <<
$statements ; separator="\n"$
>>

NewExpression(baseType, arrays) ::= <<
new $baseType$$if(arrays)$$arrays ; separator=""$$else$()$endif$
>>

ArrayAccess(arrayLength) ::= <<
[$arrayLength$]
>>

NameExpression(name) ::= <<
$name$
>>

IndexingExpression(name, indices) ::= <<
$name$$indices ; separator=""$
>>

StaticNameExpression(baseTyp, name) ::= <<
$baseTyp$.$name$
>>

StringLiteral(str) ::= <<
"$str$"
>>

CharLiteral(chr) ::= <<
'$chr$'
>>

NumericalLiteral(nm) ::= <<
$nm$
>>

AssignmentStatement(lhs, rhs) ::= <<
$lhs$ = $rhs$;
>>

ReturnStatement(varName) ::= <<
return $varName$;
>>

CallStatement(func, params, isAssignment) ::= <<
$func$($params ; separator=", "$)$if(!isAssignment)$;$endif$
>>