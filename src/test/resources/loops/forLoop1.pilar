record `com.fgwei.ForLoop1`  @kind class @AccessFlag PUBLIC {
   }
    procedure `int` `com.fgwei.ForLoop1.main` () @owner ^`com.fgwei.ForLoop1` @signature `Lcom/fgwei/ForLoop1;.main:()I` @AccessFlag PUBLIC_STATIC {
    `int` int_v2;
    `int` int_v1;
    `int` int_v0;

  #L02b558.  int_v1:= 0I;
  #L02b55a.  int_v0:= 0I;
  #L02b55c.  int_v2:= 50I;
  #L02b560.  if int_v0 >= int_v2 then goto L02b56c;
  #L02b564.  int_v1:= int_v1 + int_v0  @kind int;
  #L02b566.  int_v0:= int_v0 + 1;
  #L02b56a.  goto L02b55c;
  #L02b56c.  return int_v1;

   }
   
   
    procedure `int` `com.fgwei.ForLoop1.whileLoop` (`com.fgwei.ForLoop1` ForLoop1 @kind `this`) @owner ^`com.fgwei.ForLoop1` @signature `Lcom/fgwei/ForLoop1;.whileLoop:()I` @AccessFlag PRIVATE {
       `int` int_v2;
       `int` int_v1;
       `int` int_v0;
         
       #L02b554.  int_v1:= 0I;
       #L02b556.  int_v0:= 0I;
       #L02b558.  int_v2:= 50I;
       #L02b55c.  if int_v0 >= int_v2 then goto L02b568;
       #L02b560.  int_v1:= int_v1 + int_v0  @kind int;
       #L02b562.  int_v0:= int_v0 + 1;
       #L02b566.  goto L02b558;
       #L02b568.  return int_v1;

   }

   procedure `int` `com.fgwei.ForLoop1.whileLoop2` (`com.fgwei.ForLoop1` ForLoop1 @kind `this`) @owner ^`com.fgwei.ForLoop1` @signature `Lcom/fgwei/ForLoop1;.whileLoop2:()I` @AccessFlag PRIVATE {
        `int` int_v2;
        `int` int_v1;
        `int` int_v0;

        #L02b5c4.  int_v1:= 0I;
        #L02b5c6.  int_v0:= 0I;
        #L02b5c8.  int_v2:= 50I;
        #L02b5cc.  if int_v0 >= int_v2 then goto L02b5d8;
        #L02b5d0.  int_v1:= int_v1 + int_v0  @kind int;
        #L02b5d2.  int_v0:= int_v0 + 1;
        #L02b5d6.  goto L02b5c8;
        #L02b5d8.  int_v1:= int_v1 * 2;
        #L02b5dc.  return int_v1;

   }

    // infinite loop
     procedure `int` `com.fgwei.ForLoop1.whileLoopConditional` (`com.fgwei.ForLoop1` ForLoop1 @kind `this`) @owner ^`com.fgwei.ForLoop1` @signature `Lcom/fgwei/ForLoop1;.whileLoopConditional:()I` @AccessFlag PRIVATE {
          `int` int_v2;
             `int` int_v1;
             `int` int_v0;

           #L02b5e8.  int_v1:= 0I;
           #L02b5ea.  int_v0:= 0I;
           #L02b5ec.  int_v2:= 50I;
           #L02b5f0.  if int_v0 >= int_v2 then goto L02b608;
           #L02b5f4.  int_v1:= int_v1 + int_v0  @kind int;
           #L02b5f6.  int_v0:= int_v0 + 1;
           #L02b5fa.  int_v2:= 20I;
           #L02b5fe.  if int_v1 <= int_v2 then goto L02b5ec;
           #L02b602.  int_v1:= int_v1 * 2;
           #L02b606.  goto L02b5ec;
           #L02b608.  int_v1:= int_v1 * 2;
           #L02b60c.  return int_v1;

     }


   procedure `int` `com.fgwei.ForLoop1.nestedWhile2` (`com.fgwei.ForLoop1` ForLoop1 @kind `this`) @owner ^`com.fgwei.ForLoop1` @signature `Lcom/fgwei/ForLoop1;.nestedWhile2:()I` @AccessFlag PRIVATE {
         `int` int_v2;
            `int` int_v0;
            `int` int_v3;
            `int` int_v1;

          #L02b95c.  int_v2:= 0I;
          #L02b95e.  int_v0:= 0I;
          #L02b960.  int_v3:= 50I;
          #L02b964.  if int_v0 >= int_v3 then goto L02b97c;             //while (!(int_v0 >= int_v3)) {
          #L02b968.  int_v2:= int_v2 + int_v0  @kind int;               //  int_v2 = int_v2 + int_v0
          #L02b96a.  int_v0:= int_v0 + 1;                               //  int_v0 = int_v0 + 1;
          #L02b96e.  int_v1:= 0I;                                       //  int_v1:= 0I;
          #L02b970.  if int_v1 >= int_v0 then goto L02b960;             //  while( !(int_v1 >= int_v0)) {
          #L02b974.  int_v2:= int_v2 + int_v1  @kind int;               //      int_v2:= int_v2 + int_v1  @kind int;
          #L02b976.  int_v1:= int_v1 + 1;                               //      int_v1:= int_v1 + 1;
          #L02b97a.  goto L02b970;                                      //  }
          #L02b97c.  return int_v2;                                     //}
                                                                        //  return int_v2;
   }

   procedure `int` `com.fgwei.ForLoop1.whileLoopConditional1` (`com.fgwei.ForLoop1` ForLoop1 @kind `this`) @owner ^`com.fgwei.ForLoop1` @signature `Lcom/fgwei/ForLoop1;.whileLoopConditional1:()I` @AccessFlag PRIVATE {
        `int` int_v2;
           `int` int_v1;
           `int` int_v0;

         #L02b62c.  int_v1:= 0I;
         #L02b62e.  int_v0:= 0I;
         #L02b630.  int_v2:= 50I;
         #L02b634.  if int_v0 >= int_v2 then goto L02b652;
         #L02b638.  int_v1:= int_v1 + int_v0  @kind int;
         #L02b63a.  int_v0:= int_v0 + 1;
         #L02b63e.  int_v2:= 20I;
         #L02b642.  if int_v1 <= int_v2 then goto L02b64c;
         #L02b646.  int_v1:= int_v1 * 2;
         #L02b64a.  goto L02b630;
         #L02b64c.  int_v1:= int_v1 / 2;
         #L02b650.  goto L02b630;
         #L02b652.  int_v1:= int_v1 * 2;
         #L02b656.  return int_v1;

   }

   procedure `int` `com.fgwei.ForLoop1.nestedWhile` (`com.fgwei.ForLoop1` ForLoop1 @kind `this`) @owner ^`com.fgwei.ForLoop1` @signature `Lcom/fgwei/ForLoop1;.nestedWhile:()I` @AccessFlag PRIVATE {
         `int` int_v2;
            `int` int_v0;
            `int` int_v3;
            `int` int_v1;

          #L02b8b0.  int_v2:= 0I;
          #L02b8b2.  int_v0:= 0I;
          #L02b8b4.  int_v3:= 50I;
          #L02b8b8.  if int_v0 >= int_v3 then goto L02b8d2;
          #L02b8bc.  int_v2:= int_v2 + int_v0  @kind int;
          #L02b8be.  int_v1:= 0I;
          #L02b8c0.  if int_v1 >= int_v0 then goto L02b8cc;
          #L02b8c4.  int_v2:= int_v2 + int_v1  @kind int;
          #L02b8c6.  int_v1:= int_v1 + 1;
          #L02b8ca.  goto L02b8c0;
          #L02b8cc.  int_v0:= int_v0 + 1;
          #L02b8d0.  goto L02b8b4;
          #L02b8d2.  int_v2:= int_v2 * 2;
          #L02b8d6.  return int_v2;
   }




   procedure `int` `com.fgwei.ForLoop1.nestedWhileConditional` (`com.fgwei.ForLoop1` ForLoop1 @kind `this`) @owner ^`com.fgwei.ForLoop1` @signature `Lcom/fgwei/ForLoop1;.nestedWhileConditional:()I` @AccessFlag PRIVATE {
          `int` int_v2;                                                      //         int int_v2;
             `int` int_v0;                                                   //         int int_v0;
             `int` int_v3;                                                   //         int int_v3;
             `int` int_v1;                                                   //         int int_v1;
                                                                             //        int_v2 = 0;
           #L02b94c.  int_v2:= 0I;                                           //        int_v0 = 0;
           #L02b94e.  int_v0:= 0I;                                           //        int_v3 = 50;
           #L02b950.  int_v3:= 50I;                                          //        while(!(int_v0 >= int_v3)) {
                                                                             //          int_v2 = int_v2 + int_v0;
           #L02b954.  if int_v0 >= int_v3 then goto L02b980;                 //          int_v1 = 0;
           #L02b958.  int_v2:= int_v2 + int_v0  @kind int;                   //          if(int_v1 >= int_v0) {
           #L02b95a.  int_v1:= 0I;                                           //            int_v0 = int_v0 + 1;
                                                                             //          }
            #L02b95c.  if int_v1 >= int_v0 then goto L02b97a;                //          else {
               #L02b960.  int_v2:= int_v2 + int_v1  @kind int;               //            int_v2 = int_v2 + int_v1;
               #L02b962.  int_v3:= 1000I;                                    //            int_v3 = 1000;
                    #L02b966.  if int_v2 <= int_v3 then goto L02b974;        //            if(int_v2 <= int_v3) {
                    #L02b96a.  int_v2:= int_v2 + 251;                        //              int_v2 = int_v2 + 1;
               #L02b96e.  int_v1:= int_v1 + 1;                               //            }
               #L02b972.  goto L02b95c;                                      //            else {
                    #L02b974.  int_v2:= int_v2 + 1;                          //              int_v2 = int_v2 + 251;
                    #L02b978.  goto L02b96e;                                 //            }
               #L02b97a.  int_v0:= int_v0 + 1;                               //            int_v1 = int_v1 + 1;
            #L02b97e.  goto L02b950;                                         //          }
           #L02b980.  int_v2:= int_v2 * 2;                                   //          int_v3 = 50;
           #L02b984.  return int_v2;                                         //        }
   }


    // infinite loop
   /* procedure `int` `com.fgwei.ForLoop1.doWhileLoop` (`com.fgwei.ForLoop1` ForLoop1 @kind `this`) @owner ^`com.fgwei.ForLoop1` @signature `Lcom/fgwei/ForLoop1;.doWhileLoop:()I` @AccessFlag PRIVATE {
           `int` int_v2;
           `int` int_v1;
           `int` int_v0;

         #L02b5ac.  int_v1:= 0I;
         #L02b5ae.  int_v0:= 0I;
         #L02b5b0.  int_v1:= int_v1 + int_v0  @kind int;
         #L02b5b2.  int_v0:= int_v0 + 1;
         #L02b5b6.  int_v2:= 50I;
         #L02b5ba.  if int_v0 < int_v2 then goto L02b5b0;
         #L02b5be.  return int_v1;

   }*/